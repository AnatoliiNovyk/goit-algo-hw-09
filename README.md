# goit-algo-hw-09

# Жадібні алгоритми та динамічне програмування

# Аналіз ефективності алгоритмів для задачі видачі решти
**У рамках цього завдання було реалізовано два підходи до вирішення проблеми видачі решти: жадібний алгоритм та алгоритм динамічного програмування (ДП). Метою було порівняти їхню ефективність, особливо при роботі з великими сумами.**

## 1. Жадібний алгоритм (find_coins_greedy)
**Принцип роботи:** Алгоритм діє за простим принципом: на кожному кроці обирати найкращий локальний варіант. У контексті нашої задачі це означає послідовно брати монети найбільшого номіналу, поки не буде видано всю суму.

**Складність:** Часова складність цього алгоритму становить `O(k)`, де `k` — кількість номіналів монет. Складність не залежить від суми решти, що робить його надзвичайно швидким.

#### Переваги:
- **Швидкість:** Працює практично миттєво, що підтверджується тестами.
- **Простота:** Легкий у реалізації та розумінні.

#### Недоліки:
- Не завжди знаходить оптимальне рішення. Для наборів монет, що не є канонічними (наприклад, `[1, 3, 4]` для суми `6`), жадібний алгоритм може дати неоптимальний результат (`4+1+1` замість `3+3`). Однак для набору `[50, 25, 10, 5, 2, 1]`, що використовується в завданні, жадібний підхід завжди знаходить оптимальне рішення.

## 2. Алгоритм динамічного програмування (find_min_coins)
**Принцип роботи:** ДП є більш потужним методом, який розв'язує задачу шляхом розбиття її на менші підзадачі. Алгоритм будує таблицю, де для кожної суми від `1` до цільової `S` зберігається мінімальна кількість монет. Це гарантує знаходження глобального оптимуму для будь-якого набору номіналів.

**Складність:** Часова складність становить `O(S⋅k)`, де `S` — цільова сума, а `k` — кількість номіналів. Складність лінійно залежить від суми, що робить його повільнішим для великих значень `S`.

#### Переваги:
- **Оптимальність:** Завжди знаходить гарантовано оптимальний розв'язок (мінімальну кількість монет).

#### Недоліки:
- **Продуктивність:** Значно повільніший за жадібний алгоритм при великих сумах решти.
- **Використання пам'яті:** Потребує додаткової пам'яті для зберігання таблиці проміжних результатів (складність за пам'яттю `O(S)`).

### Порівняльний аналіз та висновки
Для заданого набору монет `[50, 25, 10, 5, 2, 1]` обидва алгоритми знаходять однаковий, оптимальний результат. Це пов'язано з тим, що цей набір є канонічним, і для нього жадібний підхід працює коректно.

Проте, ключова відмінність полягає в ефективності. Тестування на великій сумі (`123456`) наочно демонструє, що `find_coins_greedy` виконується на порядки швидше, ніж `find_min_coins`. Часова складність жадібного алгоритму `O(k)` є константною відносно суми, тоді як складність ДП `O(S⋅k)` зростає лінійно з сумою.

### Висновок: 
Для даної задачі, з урахуванням наданого набору монет, найбільш ефективним є жадібний алгоритм (`find_coins_greedy`). Він забезпечує оптимальний результат при значно менших витратах часу та пам'яті. Алгоритм динамічного програмування, хоч і є більш універсальним та надійним для довільних наборів монет, у цьому конкретному випадку є надлишковим і менш продуктивним. Його варто було б обрати, якби існувала ймовірність використання нестандартних систем номіналів, де жадібний підхід міг би зазнати невдачі.
